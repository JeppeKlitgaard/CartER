{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#introduction","title":"Introduction","text":"<p>CartER [Cartpole Environment for Reinforcement learning] is an open-source learning platform that enables the user to quickly start experimenting with simulated and physical multi-agent reinforcement learning projects quickly.</p> <p>CartER is still being actively developed and uses state-of-the-art reinforcement-learning libraries for greater reproducibility.</p>"},{"location":"#author","title":"Author","text":"<p>The CartER project is an undergraduate research project undertaken by Jeppe Klitgaard at the Biological and Soft Systems group at Cavendish Laboratory, University of Cambridge  under supervision of Professor Pietro Cicuta and Professor Pietro Lio.</p> <p>Queries can be made to jk782@cam.ac.uk or through the GitHub repository located at JeppeKlitgaard/CartER</p>"},{"location":"#citation","title":"Citation","text":"<p>CartER can be cited in publications using:</p> <pre><code>@misc{carter,\nauthor = {Jeppe Klitgaard, Pietro Cicuta, Pietro Lio},\ntitle = {CartER},\nyear = {2021},\npublisher = {GitHub},\njournal = {GitHub repository},\nhowpublished = {\\url{https://github.com/JeppeKlitgaard/CartER}},\n}\n</code></pre>"},{"location":"#documentation-overview","title":"Documentation overview","text":"<p>The documentation is incomplete and should not be taken as gospel.</p> <p>It is divided into a number of categories:</p> <ul> <li>Development: Documentation surrounding the development of the project.     Useful for advanced use or further development of the platform.</li> <li>Building: Documentation on acquiring hardware, 3D-printing parts, and assemblying the project.</li> <li>Usage: Guides on how to use the platform for machine learning.</li> <li>Articles: A collection of articles related to the project.</li> <li>Videos: A collection of videos of the project in action.</li> </ul>"},{"location":"#project-overview","title":"Project overview","text":"<p>The project consists of two main components:</p> <ul> <li><code>Commander</code>: The Python-based codebase that runs simulations, does both learning and     inference, and communicates with the <code>Controller</code> using a low-level networking protocol</li> <li><code>Controller</code>: The C/C++ based codebase that runs on Arduino SAM-based (32-bit ARM) microprocessors (namely the Arduino Due). The <code>Controller</code> handles sensors, motors, and communicating with the <code>Commander</code> over a serial interface.</li> </ul>"},{"location":"#underlying-technologies","title":"Underlying technologies","text":"<p>CartER uses the following underlying technologies.</p>"},{"location":"#commander","title":"Commander","text":"<ul> <li><code>poetry</code>: Project and package management</li> <li><code>stable_baselines3</code>: <code>pytorch</code>-based standard implementations of common model-free     reinforcement learning algorithms</li> <li><code>tensorboard</code>: For studying parameters and other output from the experiments</li> <li><code>pettingzoo</code>: Standardising the multi-agent environment</li> </ul>"},{"location":"#controller","title":"Controller","text":"<ul> <li><code>platformio</code>: Framework for embedded programming</li> </ul>"},{"location":"articles/","title":"Introduction","text":""},{"location":"articles/#introduction","title":"Introduction","text":"<p>Here you will find articles related to the project.</p> <p>These are generally not written in the formal style of an academic paper, but rather in the style one might find on Medium or Jekyll blogs.</p>"},{"location":"articles/handover_v1/","title":"Handover from 10 week internship","text":""},{"location":"articles/handover_v1/#handover-from-10-week-internship","title":"Handover from 10 week internship","text":"<p>This document describes the handover of the project after my (Jeppe Klitgaard) 10 week internship.</p> <p>Last minute change</p> <p>Before I went home on 2021-09-03 (last day) I got an epiphany that some of the weird error behaviour I have been experiencing in the last few days originates from noise from the stepper motor wires.</p> <p>I have cut some of the cable management zip ties and rearranged the wires to reduce this effect, as well as disconnected the screw mounting block for the rotary encoders.</p> <p>If it does turn out that this has fixed the issue, the cables for the steppers will need to be rerouted to reduce noise transmission after which point the cable management and the rotary encoders should be able to be reinstated without issue.</p> <p>It is possible that the noise has damaged some pins or parts of the Arduino Due, in which case the Due would need to be replaced. This seems unlikely, however.</p> <ul> <li>Jeppe</li> </ul>"},{"location":"articles/handover_v1/#what-works","title":"What works","text":"<ul> <li>Commander: Simulated Environment (Implemented as a <code>PettingZoo</code>-style <code>ParallelEnv</code>)</li> <li>Commander: Experimental Environment (Implemented as a <code>PettingZoo</code>-style <code>ParallelEnv</code>)</li> <li>Commander: Various CLI tools and utilities</li> <li>Commander: Networking protocol (serial-over-USB based, binary protocol using CPP POD's)</li> <li>Commander: Tensorboard integration with many diagonsitic metrics</li> <li>Commander: Profiling utility (<code>yappi</code>-based)</li> <li>Commander: Unified Simulation/Experiment CLI interface for running experiments</li> <li>Commander: Thorough logging for easier debugging</li> <li>Commander: Code is compliant with: <code>mypy (strict)</code>, <code>black</code>, <code>flake8</code>, and <code>isort</code>.</li> <li>Commander: Code requires Python 3.9+</li> <li>Commander: GPU (CUDA) integrated ML</li> <li>Commander: PPO model (from <code>stable-baselines3</code>)</li> <li>Commander: A2C model (from <code>stable-baselines3</code>)</li> <li>Controller: Networking protocol</li> <li>Controller: Interrupt-based stepping</li> <li>Controller: Limit finding and checking</li> <li>Controller: Pendulum jiggling</li> <li>Controller: Checks for angle and position wander during episode (logged in Tensorboard)</li> <li>Controller: Lossy network stream realignment</li> <li>Controller: High-level logic controllable over serial</li> <li>Hardware: The whole 3D printed setup</li> <li>Hardware: Steppers</li> <li>Hardware: Stepper drivers</li> <li>Hardware: 115200 baud Serial-over-USB</li> <li>Hardware: Belt tensioning system</li> </ul>"},{"location":"articles/handover_v1/#what-does-not-work","title":"What does not work","text":""},{"location":"articles/handover_v1/#rotary-encoders","title":"Rotary encoders","text":"<p>The rotary encoders have been acting very weird in the last few days. They are now disabled when the <code>FakeRotaryEncoders</code> flag is <code>true</code>, which has solved intermittent blocking and crashes. The crashes did not occur consistently or even at a particular point in the code.</p> <p>Sometimes the Arduino would randomly not exit the jiggling loop, for example. This is incredibly odd, as no I2C logic is run during that loop, nor by the stepping interrupt.</p> <p>Perhaps the rotary encoder chip is bad and causes undefined behaviour on the Arduino due to not acting as a nice I2C slave. Perhaps the Arduino has somehow been damaged, though hopefully this would not cause such inconsistent, intermittent failures.</p> <p>This may also be tangentially related to the fact that the rotary encoder does not experience a magnetic field of ideal strength. This is due to the proximity of the diametrically magnetised coin magnet to the ferromagnetic ball bearing. This distance should be increased in a later hardware revision (very easy and unintrusive, just didn't have the time).</p> <p>This, however, should also not result in the behaviour I saw.</p> <p>It is also possible that this stems from a bug in the code of the rotary encoder library (AMS_5600), which I did not fully investigate.</p> <p>It could also be due to an error in the I2C multiplexer used. Since the Due has two I2C interfaces, the multiplexer is not strictly needed, though some modification of the AMS_5600 library would be needed to use both I2C interfaces.</p>"},{"location":"articles/handover_v1/#random-arduino-resets","title":"Random Arduino Resets","text":"<p>I am getting random Arduino resets and I cannot for the life of me figure out why.</p> <p>The latest theory is that the noise from the wires going to the stepper motors is causing overvoltages on some logic lines that will then trigger a reset.</p> <p>This could be tested by disabling the motor power supply and running the experiment for a few hours. If no resets occur, it is likely a problem related to electrical noise. I haven't had time to try this, so please go ahead and try. It is some very long hanging fruit!</p>"},{"location":"articles/handover_v1/#learning-on-the-physical-system","title":"Learning on the physical system","text":"<p>I have not yet been able to get significant learning using the experimental setup. I believe as of today (my last day), the experiment will now run for extended periods of time (after disabling the rotary encoders), and so it may learn over the coming weekend.</p> <p>It could also be that the PPO/A2C algorithms used are not pleased with the inconsistent step intervals (these arise from learning causing the thread to block for tens of millisecs, as well as delays in the USB protocol and on the host computer).</p> <p>From Tensorboard it is clear that the correct rewards are being calculated and actions are being taken, though these do not seem to lead to improved behaviour over time - perhaps I simply haven't given it enough time yet.</p> <p>I don't have any obvious explanations for why the learning is not better than it currently is. I may have missed a critical bug somewhere, but since rewards and actions are both working as expected, I don't think this will be the case. Perhaps model-free reinforcement learning is just very difficult, particularly on noisy, physical systems?</p> <p>It could also be that the hyperparameters need significant tuning in order to get stable learning to occur.</p>"},{"location":"articles/handover_v1/#two-carriage-configuration","title":"Two-carriage configuration","text":"<p>Most of the code is set up to handle two carriages already, though currently the limit finding/checking routines would need to be updated to work for a two-carriage system as well.</p> <p>The hardware and electronics are fully compatible with both a one- and two-carriage configuration.</p> <p>Likely there is also some code on the environment (not agent) level in the Commander that would need fine-tuning.</p> <p>The two-carriage configuration should only be persued once the one-carriage configuration is fully working and finalised.</p>"},{"location":"articles/handover_v1/#what-could-be-improved","title":"What could be improved","text":""},{"location":"articles/handover_v1/#new-microcontroller","title":"New Microcontroller","text":"<p>Dealing with the Arduino Due has been somewhat frustrating, and while changing to a different one at this stage would require some effort, I believe that it would be worth it.</p> <p>Problematically the Arduino Due has not seen significant work done on it's core software in many years and the documentation for the board is even poorer than the already poor documentation for 8-bit AVR Arduino boards.</p> <p>I changed away from the Arduino build system fairly early on after getting frustrated with the terrible usability problems of it as well as its practically non-existant support for multiple files. Instead, the project now uses <code>platform.io</code>, which is orders of magnitude more reliable, intuitive, and well-designed.</p> <p>Ultimately, I think the same should be done for the Arduino.</p> <p>Since CartER aims to be easy to set up for others and should rely on off-the-shelf parts, I think the STM Nucleo-144 could be a very powerful option:</p> <ul> <li>Built-in debugger</li> <li>400 MHz clock speed</li> <li>Ethernet support</li> <li>Higher baudrates possible (limited to 115200 on Due due to bug in Arduino Core\ud83d\ude1e)</li> <li>Many pins broken out</li> <li>Cheap</li> <li>Readily available</li> <li><code>mbed</code>-compatible</li> </ul> <p>When doing this, it would be very worthwhile to switch away from the Arduino Wiring framework entirely, as this is incredibly poorly documented and only ever intended for hobbyist use.</p> <p>Arduino was groundbreaking in that it made access to hobby-level microcontrollers easy and open, but since then Arm has developed <code>mbed</code> which is also open and is infinitely more polished.</p> <p><code>mbed</code> even has a full RTOS version, which could be very useful for this project. This would likely make it possible to reduce fiddliness around the I2C connection with the rotary encoder, as well as a generally nicer code layout.</p> <p><code>mbed</code> + STM Nucleo-144 is supported in <code>platform.io</code>. There is an existing library for modern TMC stepper drivers for <code>mbed</code> and writing a quick library for the rotary encoder should not take long.</p>"},{"location":"articles/handover_v1/#new-stepper-drivers","title":"New stepper drivers","text":"<p>Rather than relying on the rather old TMC26X drivers, these should be changed for TMC2208/TMC2209 drivers.</p> <p>These have far better support and documentation.</p> <p>They are cheap and more readily available than the TMC26X drivers, which are strictly inferior.</p>"},{"location":"articles/handover_v1/#real-time-or-close-to-it-networking","title":"Real-time (or close to it) Networking","text":"<p>Using Serial-over-USB is far from ideal and seems to give a 4ms round-trip time in the best of cases (See: Serial).</p> <p>Since the STM board has Ethernet capability built in, it might be useful to use Ethernet for networking. This would allow far lower latency and much more reliable communication than the current implementation.</p> <p>A real-time ethernet system like EtherCAT could be used if timing becomes critical, though this will likely be overkill.</p> <p>Alternatively a proper serial connection could be used. This would require a simple level-shifting board on the controller-side and a serial board to be installed in the computer.</p> <p>Both of these options are cheap and readily available.</p> <p>Arguably Ethernet is more commonly found, though configuration can also be more complicated.</p>"},{"location":"articles/handover_v1/#getting-set-up","title":"Getting set up","text":"<p>A good way of working is using VSCode with the <code>Remote: SSH</code> functionality.</p> <p>That way, you get to develop on the powerful workstation and run experiments and simulations on it directly, but while still using your own IDE configuration and the familiar keyboard of your laptop.</p> <p>These lines, for example, were written in the rest area upstairs, but on the workstation downstairs in the Physics Lab through seamless integration via SSH and VSCode.</p> <p>More advice on how to get set up can be found in the other sections of the documentation.</p>"},{"location":"articles/introducing_carter/","title":"Introducing CartER","text":""},{"location":"articles/introducing_carter/#introducing-carter","title":"Introducing CartER","text":"<p>CartER is a physical experimental setup for the development and exploration of reinforcement learning algorithms in a reproducable, accessible way.</p> <p>The OpenAI Gym and PettingZoo projects have provided a standardised set of environments for use in single and multiagent reinforcement learning, which has  enabled the academic community to use a consistent, reproducable environment across different papers, research groups, and organisations.</p> <p>CartER enables the user to try out reinforcement learning algorithms (mainly model-free ones) on a physical system as well as a more involved cartpole environment than the one found in the OpenAI Gym.</p>"},{"location":"articles/introducing_carter/#why-do-we-care-about-physical-systems","title":"Why do we care about physical systems?","text":"<p>Physical systems are inherently noisy and introduce a variety of random and  systematic errors that prove challenging for to accurately and reliably overcome using traditional methods. Agents trained in such an environment, however, can be expected to be more resillient towards errors in the observation and action spaces.</p> <p>CartER could thus be a valuable tool for reinforcement learning researchers hoping to  battle-test their algorithms in a physical environment where resillience against latency and variable step intervals pose new challenges.</p> <p>Further, a physical system imposes constraints on inference and learning times, as the dynamics of the system will continue to act as the model is performing blocking operations.</p> <p>As such, one might expect off-policy models may outperform on-policy models in this domain, as inference and learning can more easily be separated, thus allowing for a tighter action-observation loop separate to the learning routine.</p>"},{"location":"articles/introducing_carter/#why-do-we-care-about-carter","title":"Why do we care about CartER?","text":"<p>CartER is open-source, cheap, and made of readily available parts. Thus, it lives up to many of the requirements of a standard benchmark, which will be of significant importance as the field of model-free reinforcement learning will start to more thoroughly explore viable implementations in the area of physical systems. </p>"},{"location":"articles/introducing_carter/#perspectives","title":"Perspectives","text":"<p>Studying physical systems using reinforcement learning has a number of potentially profitable perspectives.</p>"},{"location":"articles/introducing_carter/#symbolic-regression","title":"Symbolic Regression","text":"<p>Combined with symbolic regression/optimisation (cf. DSO) it may be possible to recover the equations of motion for a given physical system. While the cartpole system is well-studied and the governing equations already known, demonstrating symbolic regression using CartER could give confidence to projects hoping to recover information from more complicated systems where traditional methods may be untenable or  fail entirely.</p> <p>Further, CartER could be used in a coupled two-carriage configuration to study symbolic regression in multiagent environments or to demonstrate how reinforcement learning could be a faster, more robust way to recover information about coupled mechanical systems.</p>"},{"location":"building/","title":"Introduction","text":""},{"location":"building/#introduction","title":"Introduction","text":"<p>TODO</p> <p>This section has not been written yet. It will be written in the future once the project has reached a more mature state.</p>"},{"location":"building/bom/","title":"Bill of Materials","text":""},{"location":"building/bom/#bill-of-materials","title":"Bill of Materials","text":"<p>TODO</p> <p>This page is not done, but will be completed in the future once the hardware implementation is finalised.</p> Item Category Qty \u2248 Price Link Arduino Due Electronics 1 30 \u00a3 USB-B Micro -&gt; USB A Cable Misc. 1 2 \u00a3"},{"location":"development/","title":"Introduction","text":""},{"location":"development/#introduction","title":"Introduction","text":"<p>The development documentation is not complete, but does contain some useful pointers on how to set up the system as well as discussions of some common issues around serial connections, steppers, and networking.</p>"},{"location":"development/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml          # Documentation configuration file.\ndocs/**             # Documentation files.\npyproject.toml      # Poetry project configuration.\ncommander/**        # Commander code.\ncontroller/\n    platformio.ini  # Platform.io project configuration.\n    **              # Controller code.\nnotebooks/**        # Notebooks that are helpful in debugging or studying experiment.\n</code></pre>"},{"location":"development/cad/","title":"CAD Files","text":""},{"location":"development/cad/#cad-files","title":"CAD Files","text":"<p>The CAD has been done in Autodesk Fusion 360, which is unfortunately not very easy to share in an open-source friendly manner.</p> <p>Once downloading files from the cloud in bulk is no longer broken, CAD dumps will be available on the GitHub page.</p> <p>If you are interested in the project, please reach out to jk782@cam.ac.uk in order to get access to the CAD files through Autodesk Cloud.</p> <p>The main assembly file can be found here: Full Construction</p>"},{"location":"development/cli/","title":"Command-line interface","text":""},{"location":"development/cli/#command-line-interface","title":"Command-line interface","text":"<p>The <code>Commander</code> provides a basic commands for running simulations, though these are still will likely need to be expanded upon for further experimentation.</p> <p>The command-line interface is made available as <code>carter ...</code>. Note that this requires the <code>poetry</code> virtual environment to be activated.</p>"},{"location":"development/diagram/","title":"Diagrammatic overview","text":""},{"location":"development/diagram/#diagrammatic-overview","title":"Diagrammatic overview","text":"<p>Below is a diagrammatic overview of CartER.</p> <p></p>"},{"location":"development/further_work/","title":"Further Work (To-do)","text":""},{"location":"development/further_work/#further-work-to-do","title":"Further Work (To-do)","text":""},{"location":"development/further_work/#increase-distance-between-magnet-and-ball-bearing","title":"Increase distance between magnet and ball bearing","text":"<p>While the current setup does work fairly reliably, the distance between the diametrically magnetised magnet and the ferromagnetic housing of the ball bearing on each cart would ideally be increased to allow for higher field strengths at the rotary encoder chip.</p> <p>On start-up the system prints information about the strength of the magnet and currently reports it as below the ideal strength.</p>"},{"location":"development/installation/","title":"Installation","text":""},{"location":"development/installation/#installation","title":"Installation","text":"<p>This is an installation guide for getting setup with the software side of  things.</p> <p>It assumes: - Linux Environment - Basic knowledge of terminal environment - Visual Studio Code installed - Git installed - Python 3.9+ installed</p>"},{"location":"development/installation/#1-clone-project","title":"1 - Clone project","text":"<pre><code>git clone https://github.com/JeppeKlitgaard/CartER.git\n</code></pre>"},{"location":"development/installation/#2-platformio","title":"2 - Platform.io","text":"<ul> <li>Open the <code>CartER</code> folder in <code>vscode</code>.</li> <li>Install <code>platformio</code> if not already installed.</li> <li>If on Linux make sure to follow PlatformIO guide to udev setup</li> <li>Add the <code>CartER/controller/</code> folder to <code>vscode</code> (<code>Workspaces: Add Folder to Workspace...</code>)</li> <li>Restart <code>vscode</code></li> <li>Run <code>pio run</code> in a Platform IO terminal (<code>PlatformIO: New Terminal</code>)</li> </ul>"},{"location":"development/installation/#3-poetry","title":"3 - Poetry","text":"<ul> <li>Install Poetry</li> <li>Configure <code>poetry</code> to use local <code>venv</code> by running <code>poetry config virtualenvs.in-project true</code></li> <li>Run <code>poetry install</code> in <code>CartER/</code> directory</li> </ul> <p>Virtual Environments</p> <p>The rest of this guide assumes you are in a terminal with the project virtualenv activated.</p> <p>You can activate the virtualenv by running <code>poetry shell</code> in the <code>CartER/</code> directory.</p>"},{"location":"development/installation/#4-test","title":"4 - Test","text":"<p>Now test that you can: - Build the <code>controller</code> source using: <code>PlatformIO: Build</code> in <code>vscode</code>. - Upload to the microcontroller using <code>PlatformIO: Upload</code> in <code>vscode</code>. - Perform an experiment using <code>carter experiment</code> in a virtualenv'd shell.</p>"},{"location":"development/protocol/","title":"Protocol","text":""},{"location":"development/protocol/#protocol","title":"Protocol","text":"<p>The protocol used for serial communication is implemented using POD's (Plain Old Datatypes) and serialised to little-endian binary before being sent back and forth over a serial interface.</p> <p>Using a proper serial-connection rather than rely on the Serial-over-USB that comes standard with the Arduino Due is recommended to avoid the \u2248 4ms round-trip time in USB packet delivery.</p>"},{"location":"development/protocol/#implementation-commander","title":"Implementation - Commander","text":"<p>The protocol is best understood by reading through the <code>protocol.py</code> file on the commander. It should be fairly easily understood by those familiar with Python.</p> <p>It uses the standard library <code>struct</code> to pack and unpack data.</p>"},{"location":"development/protocol/#implementation-controller","title":"Implementation - Controller","text":"<p>The protocol must match the one implemented on the <code>commander</code> exactly, as any difference in packet lengths will lead to future misalignment that cannot easily be corrected for.</p> <p>A <code>struct</code>-like library is also used on the controller to allow for easy matching between the controller and commander protocol implementations.</p>"},{"location":"development/protocol/#packet-overview","title":"Packet overview","text":"ID (byte) ID (ASCII) Packet Direction (Controller \u2194 Commander) Fields Comment <code>0x00</code> <code>NUL</code> <code>NullPacket</code> N/A <code>id</code> Does nothing <code>0x3F</code> <code>?</code> <code>UnknownPacket</code> N/A <code>id</code> An unknown packet was found <code>0x23</code> <code>#</code> <code>DebugPacket</code> \u27f6 <code>id</code>, <code>msg</code> Debug messages <code>0x7E</code> <code>~</code> <code>InfoPacket</code> \u27f6 <code>id</code>, <code>msg</code> Info messages <code>0x21</code> <code>!</code> <code>ErrorPacket</code> \u27f6 <code>id</code>, <code>msg</code> Error messages <code>0x70</code> <code>p</code> <code>PingPacket</code> \u27f7 <code>id</code>, <code>timestamp</code> Other end should respond with a pong <code>0x50</code> <code>P</code> <code>PongPacket</code> \u27f7 <code>id</code>, <code>timestamp</code> Response to ping <code>0x24</code> <code>$</code> <code>RequestDebugInfoPacket</code> \u27f5 <code>id</code> Requests debug information from controller <code>0x78</code> <code>x</code> <code>SetPositionPacket</code> \u27f5 <code>id</code>, <code>operation</code>, <code>cart_id</code>, <code>value</code> Sets relative or absolute position <code>0x58</code> <code>X</code> <code>GetPositionPacket</code> \u27f6 <code>id</code> UNUSED. Gets position <code>0x76</code> <code>v</code> <code>SetVelocityPacket</code> \u27f5 <code>id</code>, <code>operation</code>, <code>cart_id</code>, <code>value</code> Sets relative or absolute maximum velocity <code>0x56</code> <code>V</code> <code>GetVelocityPacket</code> \u27f6 <code>id</code> UNUSED. Gets maximum velocity <code>0x7C</code> <code>|</code> <code>FindLimitsPacket</code> \u27f7 <code>id</code> Instructs controller to perform limit finding routine <code>0x2F</code> <code>/</code> <code>CheckLimitPacket</code> \u27f7 <code>id</code> Instructs controller to perform limit checking routine <code>0xA7</code> <code>\u00a7</code> <code>DoJigglePacket</code> \u27f7 <code>id</code> Instructs controller to perform a jiggle routine <code>0x40</code> <code>@</code> <code>ObservationPacket</code> \u27f6 <code>id</code>, <code>timestamp_micros</code>, <code>cart_id</code>, <code>position_steps</code>, <code>angle</code> Observed state <code>0x02</code> <code>STX</code> <code>ExperimentStartPacket</code> \u27f7 <code>id</code>, <code>timestamp_micros</code> Observed state <code>0x03</code> <code>ETX</code> <code>ExperimentEndPacket</code> \u27f7 <code>id</code> Observed state"},{"location":"development/serial/","title":"Serial","text":""},{"location":"development/serial/#serial","title":"Serial","text":"<p>The communication between the controller and the commander is done over a serial interface. This allows for real-time communication, though only when proper hardware implementations are in place on both ends.</p> <p>In most cases, serial peripherals for a PC and for the Arduino will not be available, at which point it makes sense to fall back to the Serial-over-USB capability of the Arduino Due.</p> <p>Note that this introduces latency due to the finite frame exchange interval of the USB protocol. In practice this means a round-trip time of \u2248 4ms when using Serial-over-USB.</p>"},{"location":"development/serial/#round-trip-time","title":"Round-trip time","text":"<p>The round-trip time is defined as the time from sending a ping until the  corresponding pong has been received.</p> <p>Below is a measurement of \\(5 \\cdot 10^4\\) <code>ping-pong</code> episodes. </p> <p>The vast majority of episodes seem to fall around the \\(4\\, \\text{ms}\\) mark.</p> <p></p>"},{"location":"development/serial/#protocol-alignment","title":"Protocol alignment","text":"<p>Since the Protocol operates at a byte-level, there is no easy way to realign to a packet ID if misalignment ever occurs. For this reason, a reliable serial connection is critical.</p> <p>Ensure that an appropriate baudrate is used.</p> <p>See also: Noise suppression</p>"},{"location":"development/serial/#buffer-size","title":"Buffer size","text":"<p>By default the serial buffer size of the Arduino is a measly 64 bytes, which means that it will quickly overflow and cause misalignment if not read from sufficiently often.</p> <p>This can be mitigated by ensuring that the Commander empties the serial buffer often, and further mitigated by increasing the buffer size using the <code>SERIAL_BUFFER_SIZE</code> definition.</p> <p>This can be done using platform.io in the <code>platformio.ini</code> file with a build flag <code>-DSERIAL_BUFFER_SIZE=&lt;buffer size&gt;</code></p>"},{"location":"development/serial/#noise-suppression","title":"Noise suppression","text":"<p>Currently without any noise suppression the experimental system seems to get misaligned very rarely, but this can be an issue if running the system for multiple hours or days.</p> <p>While an ACK/NACK-style protocol would arguably be the most robust choice, this would add a lot of complexity to the protocol and thus hasn't been implemented.</p> <p>Instead the Commander will request a realignment sequence to be sent by the Controller if it experiences misalignment. This does lead to some packet loss since any bytes prior to the realignment sequence will be flushed and are not resent.</p> <p>Given the rarity of noise, this approach will generally be robust enough to to have very long running experiments.</p> <p>Artificial noise can be added for testing using the constants defined in <code>PacketSender.h</code> of the Controller.</p>"},{"location":"development/stepper/","title":"Steppers","text":""},{"location":"development/stepper/#steppers","title":"Steppers","text":"<p>Having the appropriate pulse rate is critical when driving the steppers in a <code>dir/step</code> mode. From the datasheet of, for example, the RS PRO 5350479 stepper motor, we can see that a pulse rate of \\(\u2248 5\\ \\text{kHz}\\) would be ideal  if torque is the main concern.</p> <p>In order to achieve a reliable pulse rate, we can utilise timer interrupts, which is done using the <code>tc_lib</code> library for Arduino SAM. If you use a different board, you may need to use a different library or implement the timer interrupts by hand.</p> <p>Thus we which to have a timer period of:</p> \\[ T = f^{-1} = \\frac{1}{5000} = 2 \u22c5 10^{-4} s = 2 \u22c5 10^{4} \\ \\qty[10^{-8}\\, s] \\]"},{"location":"usage/","title":"Introduction","text":""},{"location":"usage/#introduction","title":"Introduction","text":"<p>This section of the documentation contains usage guides on how to set up CartpoleML for use in machine learning projects.</p> <p>TODO</p> <p>This part of the documentation has not yet been written.</p>"},{"location":"videos/","title":"Introduction","text":""},{"location":"videos/#introduction","title":"Introduction","text":"<p>The part of the documentation hosts a variety of videos demonstrating some of the possibilities of the project</p>"},{"location":"videos/movements_using_ppo/","title":"Movements using PPO algorithm","text":""},{"location":"videos/movements_using_ppo/#movements-using-ppo-algorithm","title":"Movements using PPO algorithm","text":"<p>This video demonstrates carriage movements in a single-carriage configuration using the PPO model implementation of <code>stable-baselines3</code>.</p> <p></p>"}]}